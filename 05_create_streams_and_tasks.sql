-- =============================================================================
-- STREAMS AND TASKS CREATION
-- =============================================================================
-- This approach uses Streams to capture changes from stage tables and Tasks to
-- process those changes with MERGE operations into latest data tables
-- 
-- ARCHITECTURE:
-- Stage Tables → Streams (capture changes) → Tasks (process with MERGE) → Latest Tables
--
-- BENEFITS over Dynamic Tables:
-- - More control over merge logic and business rules
-- - Better monitoring and error handling
-- - Flexible scheduling and batch processing
-- - Custom transformation logic in tasks
-- - Better handling of complex deduplication scenarios
-- =============================================================================

USE SCHEMA SNOWPIPE_DT_DEMO.LATEST_DATA;

-- =============================================================================
-- SECTION 1: CREATE LATEST DATA TABLES (TARGET TABLES FOR MERGE)
-- =============================================================================

-- 1. LATEST CUSTOMERS TABLE
CREATE OR REPLACE TABLE LATEST_CUSTOMERS (
    CUSTOMER_ID NUMBER,
    CUSTOMER_NAME STRING,
    EMAIL STRING,
    PHONE STRING,
    ADDRESS STRING,
    CITY STRING,
    STATE STRING,
    ZIP_CODE STRING,
    COUNTRY STRING,
    RECORD_TIMESTAMP TIMESTAMP_NTZ,
    DATA_VERSION NUMBER,
    RECORD_STATUS STRING,
    LOAD_TIMESTAMP TIMESTAMP_NTZ,
    STREAM_PROCESSED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    PRIMARY KEY (CUSTOMER_ID)
);

-- 2. LATEST PRODUCTS TABLE
CREATE OR REPLACE TABLE LATEST_PRODUCTS (
    PRODUCT_ID NUMBER,
    PRODUCT_NAME STRING,
    CATEGORY STRING,
    SUBCATEGORY STRING,
    BRAND STRING,
    PRICE NUMBER(10,2),
    COST NUMBER(10,2),
    SUPPLIER_ID NUMBER,
    DESCRIPTION STRING,
    RECORD_TIMESTAMP TIMESTAMP_NTZ,
    DATA_VERSION NUMBER,
    RECORD_STATUS STRING,
    LOAD_TIMESTAMP TIMESTAMP_NTZ,
    STREAM_PROCESSED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    PRIMARY KEY (PRODUCT_ID)
);

-- 3. LATEST ORDERS TABLE
CREATE OR REPLACE TABLE LATEST_ORDERS (
    ORDER_ID NUMBER,
    CUSTOMER_ID NUMBER,
    ORDER_DATE DATE,
    ORDER_STATUS STRING,
    ORDER_TOTAL NUMBER(10,2),
    PAYMENT_METHOD STRING,
    SHIPPING_ADDRESS STRING,
    BILLING_ADDRESS STRING,
    ORDER_PRIORITY STRING,
    RECORD_TIMESTAMP TIMESTAMP_NTZ,
    DATA_VERSION NUMBER,
    RECORD_STATUS STRING,
    LOAD_TIMESTAMP TIMESTAMP_NTZ,
    STREAM_PROCESSED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    PRIMARY KEY (ORDER_ID)
);

-- 4. LATEST ORDER ITEMS TABLE
CREATE OR REPLACE TABLE LATEST_ORDER_ITEMS (
    ORDER_ITEM_ID NUMBER,
    ORDER_ID NUMBER,
    PRODUCT_ID NUMBER,
    QUANTITY NUMBER,
    UNIT_PRICE NUMBER(10,2),
    DISCOUNT_PERCENT NUMBER(5,2),
    LINE_TOTAL NUMBER(10,2),
    RECORD_TIMESTAMP TIMESTAMP_NTZ,
    DATA_VERSION NUMBER,
    RECORD_STATUS STRING,
    LOAD_TIMESTAMP TIMESTAMP_NTZ,
    STREAM_PROCESSED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    PRIMARY KEY (ORDER_ITEM_ID)
);

-- 5. LATEST SUPPLIERS TABLE
CREATE OR REPLACE TABLE LATEST_SUPPLIERS (
    SUPPLIER_ID NUMBER,
    SUPPLIER_NAME STRING,
    CONTACT_PERSON STRING,
    EMAIL STRING,
    PHONE STRING,
    ADDRESS STRING,
    CITY STRING,
    STATE STRING,
    COUNTRY STRING,
    RATING NUMBER(2,1),
    RECORD_TIMESTAMP TIMESTAMP_NTZ,
    DATA_VERSION NUMBER,
    RECORD_STATUS STRING,
    LOAD_TIMESTAMP TIMESTAMP_NTZ,
    STREAM_PROCESSED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    PRIMARY KEY (SUPPLIER_ID)
);

-- Create remaining tables with similar structure...
-- (For brevity, showing pattern for first 5 tables)

-- =============================================================================
-- SECTION 2: CREATE STREAMS ON STAGE TABLES
-- =============================================================================

USE SCHEMA SNOWPIPE_DT_DEMO.STAGE_DATA;

-- 1. CUSTOMERS STREAM
CREATE OR REPLACE STREAM STG_CUSTOMERS_STREAM 
ON TABLE SNOWPIPE_DT_DEMO.STAGE_DATA.STG_CUSTOMERS
APPEND_ONLY = FALSE  -- Capture all DML operations
SHOW_INITIAL_ROWS = TRUE;  -- Include existing rows when stream is created

-- 2. PRODUCTS STREAM  
CREATE OR REPLACE STREAM STG_PRODUCTS_STREAM 
ON TABLE SNOWPIPE_DT_DEMO.STAGE_DATA.STG_PRODUCTS
APPEND_ONLY = FALSE  -- Capture all DML operations
SHOW_INITIAL_ROWS = TRUE;  -- Include existing rows when stream is created

-- 3. ORDERS STREAM
CREATE OR REPLACE STREAM STG_ORDERS_STREAM 
ON TABLE SNOWPIPE_DT_DEMO.STAGE_DATA.STG_ORDERS
APPEND_ONLY = FALSE  -- Capture all DML operations
SHOW_INITIAL_ROWS = TRUE;  -- Include existing rows when stream is created

-- 4. ORDER ITEMS STREAM
CREATE OR REPLACE STREAM STG_ORDER_ITEMS_STREAM 
ON TABLE SNOWPIPE_DT_DEMO.STAGE_DATA.STG_ORDER_ITEMS
APPEND_ONLY = FALSE  -- Capture all DML operations
SHOW_INITIAL_ROWS = TRUE;  -- Include existing rows when stream is created

-- 5. SUPPLIERS STREAM  
CREATE OR REPLACE STREAM STG_SUPPLIERS_STREAM 
ON TABLE SNOWPIPE_DT_DEMO.STAGE_DATA.STG_SUPPLIERS
APPEND_ONLY = FALSE  -- Capture all DML operations
SHOW_INITIAL_ROWS = TRUE;  -- Include existing rows when stream is created

-- 6. INVENTORY STREAM
CREATE OR REPLACE STREAM STG_INVENTORY_STREAM 
ON TABLE SNOWPIPE_DT_DEMO.STAGE_DATA.STG_INVENTORY
APPEND_ONLY = FALSE  -- Capture all DML operations
SHOW_INITIAL_ROWS = TRUE;  -- Include existing rows when stream is created

-- 7. WAREHOUSES STREAM  
CREATE OR REPLACE STREAM STG_WAREHOUSES_STREAM 
ON TABLE SNOWPIPE_DT_DEMO.STAGE_DATA.STG_WAREHOUSES
APPEND_ONLY = FALSE  -- Capture all DML operations
SHOW_INITIAL_ROWS = TRUE;  -- Include existing rows when stream is created

-- 8. EMPLOYEES STREAM
CREATE OR REPLACE STREAM STG_EMPLOYEES_STREAM 
ON TABLE SNOWPIPE_DT_DEMO.STAGE_DATA.STG_EMPLOYEES
APPEND_ONLY = FALSE  -- Capture all DML operations
SHOW_INITIAL_ROWS = TRUE;  -- Include existing rows when stream is created

-- 9. TERRITORIES STREAM  
CREATE OR REPLACE STREAM STG_TERRITORIES_STREAM 
ON TABLE SNOWPIPE_DT_DEMO.STAGE_DATA.STG_TERRITORIES
APPEND_ONLY = FALSE  -- Capture all DML operations
SHOW_INITIAL_ROWS = TRUE;  -- Include existing rows when stream is created

-- 10. PROMOTIONS STREAM
CREATE OR REPLACE STREAM STG_PROMOTIONS_STREAM 
ON TABLE SNOWPIPE_DT_DEMO.STAGE_DATA.STG_PROMOTIONS
APPEND_ONLY = FALSE  -- Capture all DML operations
SHOW_INITIAL_ROWS = TRUE;  -- Include existing rows when stream is created

-- =============================================================================
-- SECTION 3: CREATE TASKS TO PROCESS STREAMS WITH MERGE LOGIC
-- =============================================================================

-- Create warehouse for task execution
CREATE WAREHOUSE IF NOT EXISTS STREAMS_TASKS_WH 
WITH WAREHOUSE_SIZE = 'SMALL' 
AUTO_SUSPEND = 60 
AUTO_RESUME = TRUE;

-- Set schema context for task creation (tasks will reference streams from STAGE_DATA)
USE SCHEMA SNOWPIPE_DT_DEMO.STAGE_DATA;

-- 1. CUSTOMERS PROCESSING TASK
CREATE OR REPLACE TASK PROCESS_CUSTOMERS_STREAM
WAREHOUSE = STREAMS_TASKS_WH
SCHEDULE = '1 MINUTE'  -- Run every minute to process changes
WHEN SYSTEM$STREAM_HAS_DATA('SNOWPIPE_DT_DEMO.STAGE_DATA.STG_CUSTOMERS_STREAM')
AS
MERGE INTO SNOWPIPE_DT_DEMO.LATEST_DATA.LATEST_CUSTOMERS AS target
USING (
    -- Get only the latest version for each customer from the stream
    SELECT 
        CUSTOMER_ID,
        CUSTOMER_NAME,
        EMAIL,
        PHONE,
        ADDRESS,
        CITY,
        STATE,
        ZIP_CODE,
        COUNTRY,
        RECORD_TIMESTAMP,
        DATA_VERSION,
        RECORD_STATUS,
        LOAD_TIMESTAMP
    FROM (
        SELECT 
            CUSTOMER_ID,
            CUSTOMER_NAME,
            EMAIL,
            PHONE,
            ADDRESS,
            CITY,
            STATE,
            ZIP_CODE,
            COUNTRY,
            RECORD_TIMESTAMP,
            DATA_VERSION,
            RECORD_STATUS,
            LOAD_TIMESTAMP,
            ROW_NUMBER() OVER (
                PARTITION BY CUSTOMER_ID 
                ORDER BY DATA_VERSION DESC, RECORD_TIMESTAMP DESC, LOAD_TIMESTAMP DESC
            ) as rn
        FROM STG_CUSTOMERS_STREAM
        WHERE METADATA$ACTION = 'INSERT'  -- Only process new records
    )
    WHERE rn = 1  -- Only keep the latest version per customer
) AS source
ON target.CUSTOMER_ID = source.CUSTOMER_ID
WHEN MATCHED AND target.DATA_VERSION < source.DATA_VERSION THEN 
    UPDATE SET 
        CUSTOMER_NAME = source.CUSTOMER_NAME,
        EMAIL = source.EMAIL,
        PHONE = source.PHONE,
        ADDRESS = source.ADDRESS,
        CITY = source.CITY,
        STATE = source.STATE,
        ZIP_CODE = source.ZIP_CODE,
        COUNTRY = source.COUNTRY,
        RECORD_TIMESTAMP = source.RECORD_TIMESTAMP,
        DATA_VERSION = source.DATA_VERSION,
        RECORD_STATUS = source.RECORD_STATUS,
        LOAD_TIMESTAMP = source.LOAD_TIMESTAMP,
        STREAM_PROCESSED_AT = CURRENT_TIMESTAMP()
WHEN NOT MATCHED THEN
    INSERT (
        CUSTOMER_ID, CUSTOMER_NAME, EMAIL, PHONE, ADDRESS, CITY, STATE, 
        ZIP_CODE, COUNTRY, RECORD_TIMESTAMP, DATA_VERSION, RECORD_STATUS, 
        LOAD_TIMESTAMP, STREAM_PROCESSED_AT
    ) VALUES (
        source.CUSTOMER_ID, source.CUSTOMER_NAME, source.EMAIL, source.PHONE,
        source.ADDRESS, source.CITY, source.STATE, source.ZIP_CODE, source.COUNTRY,
        source.RECORD_TIMESTAMP, source.DATA_VERSION, source.RECORD_STATUS,
        source.LOAD_TIMESTAMP, CURRENT_TIMESTAMP()
    );

-- 2. PRODUCTS PROCESSING TASK
CREATE OR REPLACE TASK PROCESS_PRODUCTS_STREAM
WAREHOUSE = STREAMS_TASKS_WH
SCHEDULE = '1 MINUTE'
WHEN SYSTEM$STREAM_HAS_DATA('SNOWPIPE_DT_DEMO.STAGE_DATA.STG_PRODUCTS_STREAM')
AS
MERGE INTO SNOWPIPE_DT_DEMO.LATEST_DATA.LATEST_PRODUCTS AS target
USING (
    SELECT 
        PRODUCT_ID,
        PRODUCT_NAME,
        CATEGORY,
        PRICE,
        SUPPLIER_ID,
        RECORD_TIMESTAMP,
        DATA_VERSION,
        RECORD_STATUS,
        LOAD_TIMESTAMP
    FROM (
        SELECT 
            PRODUCT_ID,
            PRODUCT_NAME,
            CATEGORY,
            PRICE,
            SUPPLIER_ID,
            RECORD_TIMESTAMP,
            DATA_VERSION,
            RECORD_STATUS,
            LOAD_TIMESTAMP,
            ROW_NUMBER() OVER (
                PARTITION BY PRODUCT_ID 
                ORDER BY DATA_VERSION DESC, RECORD_TIMESTAMP DESC, LOAD_TIMESTAMP DESC
            ) as rn
        FROM STG_PRODUCTS_STREAM
        WHERE METADATA$ACTION = 'INSERT'
    )
    WHERE rn = 1  -- Only keep the latest version per product
) AS source
ON target.PRODUCT_ID = source.PRODUCT_ID
WHEN MATCHED AND target.DATA_VERSION < source.DATA_VERSION THEN 
    UPDATE SET 
        PRODUCT_NAME = source.PRODUCT_NAME,
        CATEGORY = source.CATEGORY,
        PRICE = source.PRICE,
        SUPPLIER_ID = source.SUPPLIER_ID,
        RECORD_TIMESTAMP = source.RECORD_TIMESTAMP,
        DATA_VERSION = source.DATA_VERSION,
        RECORD_STATUS = source.RECORD_STATUS,
        LOAD_TIMESTAMP = source.LOAD_TIMESTAMP,
        STREAM_PROCESSED_AT = CURRENT_TIMESTAMP()
WHEN NOT MATCHED THEN
    INSERT (
        PRODUCT_ID, PRODUCT_NAME, CATEGORY, PRICE, SUPPLIER_ID,
        RECORD_TIMESTAMP, DATA_VERSION, RECORD_STATUS, LOAD_TIMESTAMP, STREAM_PROCESSED_AT
    ) VALUES (
        source.PRODUCT_ID, source.PRODUCT_NAME, source.CATEGORY, source.PRICE, 
        source.SUPPLIER_ID, source.RECORD_TIMESTAMP, source.DATA_VERSION, 
        source.RECORD_STATUS, source.LOAD_TIMESTAMP, CURRENT_TIMESTAMP()
    );

-- 3. ORDERS PROCESSING TASK
CREATE OR REPLACE TASK PROCESS_ORDERS_STREAM
WAREHOUSE = STREAMS_TASKS_WH
SCHEDULE = '1 MINUTE'
WHEN SYSTEM$STREAM_HAS_DATA('SNOWPIPE_DT_DEMO.STAGE_DATA.STG_ORDERS_STREAM')
AS
MERGE INTO SNOWPIPE_DT_DEMO.LATEST_DATA.LATEST_ORDERS AS target
USING (
    SELECT 
        ORDER_ID,
        CUSTOMER_ID,
        ORDER_DATE,
        TOTAL_AMOUNT,
        ORDER_STATUS,
        RECORD_TIMESTAMP,
        DATA_VERSION,
        RECORD_STATUS,
        LOAD_TIMESTAMP
    FROM (
        SELECT 
            ORDER_ID,
            CUSTOMER_ID,
            ORDER_DATE,
            TOTAL_AMOUNT,
            ORDER_STATUS,
            RECORD_TIMESTAMP,
            DATA_VERSION,
            RECORD_STATUS,
            LOAD_TIMESTAMP,
            ROW_NUMBER() OVER (
                PARTITION BY ORDER_ID 
                ORDER BY DATA_VERSION DESC, RECORD_TIMESTAMP DESC, LOAD_TIMESTAMP DESC
            ) as rn
        FROM STG_ORDERS_STREAM
        WHERE METADATA$ACTION = 'INSERT'
    )
    WHERE rn = 1  -- Only keep the latest version per order
) AS source
ON target.ORDER_ID = source.ORDER_ID
WHEN MATCHED AND target.DATA_VERSION < source.DATA_VERSION THEN 
    UPDATE SET 
        CUSTOMER_ID = source.CUSTOMER_ID,
        ORDER_DATE = source.ORDER_DATE,
        TOTAL_AMOUNT = source.TOTAL_AMOUNT,
        ORDER_STATUS = source.ORDER_STATUS,
        RECORD_TIMESTAMP = source.RECORD_TIMESTAMP,
        DATA_VERSION = source.DATA_VERSION,
        RECORD_STATUS = source.RECORD_STATUS,
        LOAD_TIMESTAMP = source.LOAD_TIMESTAMP,
        STREAM_PROCESSED_AT = CURRENT_TIMESTAMP()
WHEN NOT MATCHED THEN
    INSERT (
        ORDER_ID, CUSTOMER_ID, ORDER_DATE, TOTAL_AMOUNT, ORDER_STATUS,
        RECORD_TIMESTAMP, DATA_VERSION, RECORD_STATUS, LOAD_TIMESTAMP, STREAM_PROCESSED_AT
    ) VALUES (
        source.ORDER_ID, source.CUSTOMER_ID, source.ORDER_DATE, source.TOTAL_AMOUNT,
        source.ORDER_STATUS, source.RECORD_TIMESTAMP, source.DATA_VERSION, 
        source.RECORD_STATUS, source.LOAD_TIMESTAMP, CURRENT_TIMESTAMP()
    );

-- =============================================================================
-- SECTION 4: ENABLE TASK SCHEDULING
-- =============================================================================

-- Resume tasks to start processing
ALTER TASK PROCESS_CUSTOMERS_STREAM RESUME;
ALTER TASK PROCESS_PRODUCTS_STREAM RESUME;
ALTER TASK PROCESS_ORDERS_STREAM RESUME;

-- =============================================================================
-- SECTION 5: MONITORING QUERIES
-- =============================================================================

-- Check stream status
SELECT 
    'STG_CUSTOMERS_STREAM' as STREAM_NAME,
    SYSTEM$STREAM_HAS_DATA('SNOWPIPE_DT_DEMO.STAGE_DATA.STG_CUSTOMERS_STREAM') as HAS_DATA
UNION ALL
SELECT 
    'STG_PRODUCTS_STREAM',
    SYSTEM$STREAM_HAS_DATA('SNOWPIPE_DT_DEMO.STAGE_DATA.STG_PRODUCTS_STREAM')
UNION ALL
SELECT 
    'STG_ORDERS_STREAM',
    SYSTEM$STREAM_HAS_DATA('SNOWPIPE_DT_DEMO.STAGE_DATA.STG_ORDERS_STREAM');

-- Check task history
SELECT 
    NAME,
    STATE,
    SCHEDULED_TIME,
    COMPLETED_TIME,
    RETURN_VALUE
FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY())
WHERE NAME IN ('PROCESS_CUSTOMERS_STREAM', 'PROCESS_PRODUCTS_STREAM', 'PROCESS_ORDERS_STREAM')
ORDER BY SCHEDULED_TIME DESC
LIMIT 20;

-- Show stream contents (for debugging)  
USE SCHEMA SNOWPIPE_DT_DEMO.STAGE_DATA;
SELECT * FROM STG_CUSTOMERS_STREAM LIMIT 10;
USE SCHEMA SNOWPIPE_DT_DEMO.LATEST_DATA;

-- Check latest data
SELECT 
    'CUSTOMERS' as TABLE_NAME,
    COUNT(*) as LATEST_RECORDS,
    MAX(STREAM_PROCESSED_AT) as LAST_PROCESSED
FROM SNOWPIPE_DT_DEMO.LATEST_DATA.LATEST_CUSTOMERS
UNION ALL
SELECT 
    'PRODUCTS',
    COUNT(*),
    MAX(STREAM_PROCESSED_AT)
FROM SNOWPIPE_DT_DEMO.LATEST_DATA.LATEST_PRODUCTS
UNION ALL
SELECT 
    'ORDERS',
    COUNT(*),
    MAX(STREAM_PROCESSED_AT)  
FROM SNOWPIPE_DT_DEMO.LATEST_DATA.LATEST_ORDERS;
